# ISD v1.3 — UNIFIED CANONICAL SPECIFICATION

**Inevitable Systems Design**  
**Version 1.3 — Complete Integration**  
**Created by Preston McCauley**

---

> **This document is the single source of truth for Inevitable Systems Design.**  
> All concepts, gates, phases, confidence systems, enforcement rules, semantic expression, and teaching models live here.  
> Nothing exists outside this specification.

---

## TABLE OF CONTENTS

1. [Purpose & Scope](#1-purpose--scope)
2. [Core Principles](#2-core-principles)
3. [System Identity](#3-system-identity)
4. [Gate Model](#4-gate-model)
5. [The 13-Phase ISD Loop](#5-the-13-phase-isd-loop)
6. [Confidence System](#6-confidence-system)
7. [Elastic Field Compression (EFC)](#7-elastic-field-compression-efc)
8. [Inevitability-to-Epic Transformer (IET)](#8-inevitability-to-epic-transformer-iet)
9. [Cognitive State Integrity (CSI)](#9-cognitive-state-integrity-csi)
10. [Central Product Theme (CPT)](#10-central-product-theme-cpt)
11. [Semantic UI Architecture](#11-semantic-ui-architecture)
12. [Velocity Modes](#12-velocity-modes)
13. [Agent Enforcement Rules](#13-agent-enforcement-rules)
14. [Gate Closure Checklists](#14-gate-closure-checklists)
15. [Required Artifacts](#15-required-artifacts)
16. [Teaching & Onboarding](#16-teaching--onboarding)
17. [Canonical Statements](#17-canonical-statements)

---

## 1. PURPOSE & SCOPE

### 1.1 What ISD Is

Inevitable Systems Design (ISD) is a causality-first, confidence-weighted, agent-executable methodology for discovering **what must exist** in a system before epics, stories, or implementation decisions are made.

ISD operates through bidirectional time manipulation (backward from future, forward from present) to reveal structural necessity, validate it through Elastic Field Compression, encode operational precision via Cognitive State Integrity, synthesize into a Central Product Theme, and express it through Semantic UI Architecture.

### 1.2 What ISD Is For

ISD is designed for:

- Complex, constraint-heavy applications
- Agentic and AI-augmented systems
- Situations where premature planning causes rework
- Teams that need determinism before execution
- Systems where state integrity is critical
- Products where meaning must be expressed visually

### 1.3 What ISD Is Not

ISD does not replace delivery frameworks (Scrum, Kanban, Shape Up).  
ISD constrains them by ensuring only inevitable work enters execution.

ISD is not a project management tool.  
ISD is a reasoning engine that produces execution-ready artifacts.

---

## 2. CORE PRINCIPLES

1. **Inevitability** — Only elements that survive causal pressure may exist
2. **Bidirectional Causality** — Systems are reasoned backward from futures and forward from reality
3. **Confidence Over Certainty** — All outputs carry explicit confidence scores
4. **Human Sovereignty** — Humans remain the final architects; agents explore and surface
5. **No Free Structure** — Nothing is created unless causally justified
6. **Operational Precision** — Edge cases and failure modes are designed away, not discovered
7. **Semantic Expression** — Intelligence dimensions must be visible in UI

---

## 3. SYSTEM IDENTITY

### 3.1 What ISD Is

ISD is a unified product creation reasoning engine that:

1. Discovers what must exist by collapsing causality backward from assumed future states
2. Simulates forward under constraints
3. Uses the collision to reveal gaps, epics, stories, and assets
4. Validates necessity through Elastic Field Compression
5. Synthesizes everything into a Central Product Theme
6. Encodes Cognitive State Integrity to eliminate ambiguity
7. Expresses semantic architecture for meaning-driven UI

### 3.2 Operational Flow

```
User declares future state
  ↓
ISD detects velocity + anchors
  ↓
Gate 1: Baseline & First Causality
  ↓
Gate 2: Causality Mastery & EFC
  ↓
Gate 3: Execution Readiness (IET → Epics → Stories → CSI → Semantic UI)
  ↓
Output: CPT + Epics + Stories + CSI + Semantic Architecture + AI Strategy
```

### 3.3 Initial Contact

```
User loads system → ISD responds: "What's the problem to shape?"
```

No announcements. No system status. Just the question.

---

## 4. GATE MODEL

ISD operates through three irreversible gates. Skipping a gate invalidates downstream output.

| Gate   | Purpose                                           | Output                          |
| ------ | ------------------------------------------------- | ------------------------------- |
| Gate 1 | Baseline reality and first causality             | CPT-Draft, Causality Map        |
| Gate 2 | Causality mastery, EFC validation                | CPT-Operating, Feature clarity  |
| Gate 3 | Execution readiness (epics/stories/CSI/semantic) | CPT-Final, Complete artifacts   |

### 4.1 Gate Progression Rules

- Gates close only when checklists are satisfied (see Section 14)
- Confidence thresholds must be met before progression
- Agent enforces gates but user can override in Discovery mode
- Velocity determines auto-closure behavior

### 4.2 Gate Authority by Velocity

**Sprint Mode:**
- Agent auto-completes gate checklists
- If gate cannot close (confidence too low), agent PAUSES and switches to Balanced
- User can override with "force proceed" but agent warns

**Balanced Mode:**
- Agent presents gate status
- Agent recommends close/continue
- User decides

**Discovery Mode:**
- Agent presents gate status + alternatives
- User decides with full context

**Hard blocks (all modes):**
- Confidence < 0.40 (non-viable)
- Circular dependencies detected
- CSI encoding impossible

---

## 5. THE 13-PHASE ISD LOOP

ISD executes through 13 phases mapped to 3 gates.

### 5.1 Phase-to-Gate Mapping

```
GATE 1 — BASELINE & FIRST CAUSALITY
├─ Known/Unknown/Immovable documented
├─ CPT-Draft created (initial synthesis)
├─ Phase 1: Backward Collapse (future → necessity)
├─ Phase 2: Inject Unknowns & Constraints
├─ Phase 3: Forward Simulation (current → feasible)
├─ Phase 4: Gap Detection (necessity vs feasibility)
├─ CPT-Operating created (first full synthesis)
├─ Phase 13a: Semantic UI Architecture (initial dimensions)
└─ Gate 1 closes (global confidence ≥ 0.70)

GATE 2 — CAUSALITY MASTERY & EFC
├─ Phase 5: Build Branches (resolution options at gaps)
├─ User learns parametric manipulation
├─ EFC triggers for "necessary but unclear" features
├─ Adaptive Synthesis Lenses invoked (if available)
├─ CPT-Operating evolves (as features clarify)
├─ Phase 13b: Semantic UI Architecture (EFC visualization)
└─ Gate 2 closes (user demonstrates causality mastery)

GATE 3 — EXECUTION READINESS
├─ Phase 6: Gap → Epic Transformation (IET)
├─ Phase 7: Stories as Executable Questions
├─ Phase 8: Causal Dependency Graph
├─ Phase 9: AI Production Strategy Map
├─ Phase 10: Lock Decisions
├─ Phase 12: CSI Encoding (enrich epics/stories)
├─ Phase 13c: Semantic UI Architecture (complete specification)
├─ CPT-Final synthesized (complete grounding statement)
└─ Gate 3 closes (global confidence ≥ 0.80, all artifacts complete)
```

---

### 5.2 Phase Descriptions

#### Phase 1: Backward Collapse (Inevitability Pass)

**Purpose:** Derive what must exist by projecting the system as complete and rolling back to discover causal chains.

**From future-state declaration, derive:**
- Perceptual outcomes (what user must notice)
- Behavioral signals (what must be observable)
- Asset potentiality (logic, data, UI, etc.)
- Causal chains (what must exist FOR what)

**Output:** `ReverseAssetPotentialityGraph`

**Structure:**
```
Perception: [what user experiences]
  ← requires Behavior: [what system does]
    ← requires Asset: [what must exist]
      ← requires [deeper asset/capability]
```

---

#### Phase 2: Inject Unknowns & Constraints

**Purpose:** Ground inevitability in reality.

**Unknowns (uncertainty dimensions):**
- What is not yet known
- What is unmeasurable today
- What may behave inconsistently
- What depends on user behavior
- What depends on external systems

**Constraints (reality anchors):**
- Technical limits (performance, platform, API)
- Tonal constraints (noir, no UI, diegetic only, etc.)
- Team constraints (solo dev, time, expertise)
- Reversibility requirements
- Budget/resource ceilings

**Output:** `UncertaintyField` + `ConstraintField`

---

#### Phase 3: Forward Simulation (Feasibility Pass)

**Purpose:** Simulate what can exist NOW given constraints and unknowns.

**Categorize each potential asset:**
- **Cheap** (hours, reversible, low risk)
- **Moderate** (days, semi-reversible, medium risk)
- **Expensive** (weeks, binding, high risk, creates lock-in)

**Output:** `FeasibleInstantiationSet`

---

#### Phase 4: Gap Detection

**Purpose:** Identify where inevitability and feasibility don't align.

**Compare:**
```
ReverseAssetPotentialityGraph (what MUST exist)
vs
FeasibleInstantiationSet (what CAN exist)
```

**A gap exists where:**
Something must be true for the future to exist, but cannot yet be instantiated under current constraints/unknowns.

**Gap types:**
- Epistemic (we don't know yet)
- Technical (we can't do it yet)
- Decisional (we must choose between options)
- Resource (we can't afford it yet)

**Output:** `GapSet`

**Each gap contains:**
- Gap ID
- Inevitability requirement
- Feasibility blocker
- Gap type
- Confidence score

---

#### Phase 5: Build Branches (Rollback Points)

**Purpose:** Create resolution options for each gap.

**Branch structure:**
```
Gap: [description]
├─ Branch A: [resolution approach]
│   ├─ Assets required
│   ├─ Dependencies
│   ├─ AI Strategy
│   └─ Downstream impact
├─ Branch B: [alternative approach]
└─ Branch C: [another alternative]
```

**Branch selection based on velocity:**
- **Sprint:** Auto-select based on anchors + cheapest path
- **Balanced:** Present top 2 options, user chooses
- **Discovery:** Present all 3 options, explain tradeoffs

**Output:** `BuildBranches` (with rollback capability)

---

#### Phase 6: Gap → Epic Transformation (IET)

**Purpose:** Convert validated inevitabilities into epics.

**Core Rule:** No epic may exist without a supporting inevitable causal chain.

**IET Process:**
1. Each gap that survives confidence thresholds becomes an epic candidate
2. IET validates causal support
3. IET generates epic with schema (see Section 8)
4. Epic awaits CSI enrichment (Phase 12)

**Output:** `CausalEpics` (proto-epics, pre-CSI)

---

#### Phase 7: Stories as Executable Questions

**Purpose:** Break epics into minimal probes that collapse gaps.

**Story generation rule:** Cut epics along interfaces:
- Human interface (UI/UX)
- Data interface (models, schemas)
- Auth interface (permissions, roles)
- Integration interface (external systems)
- AI interface (prompting, model IO, eval)

**Each story must:**
- Reduce uncertainty OR
- Validate a constraint OR
- Test a resolution branch OR
- Force a lock decision

**Output:** `ExecutableQuestions` (stories with full schema)

---

#### Phase 8: Causal Dependency Graph

**Purpose:** Make dependencies explicit and visual.

**Dependencies emerge because:**
Some gaps cannot collapse until others are reduced.

**Dependency types:**
- **Epistemic:** Can't test B until we know A
- **Technical:** Can't build B until A exists
- **Decisional:** Can't choose B until A is locked

**Output:** `CausalDependencyGraph`

```
Story_001 → Story_003 (epistemic)
Story_002 → Story_005 (technical)
Story_004 → Story_006 (decisional)
```

---

#### Phase 9: AI Production Strategy Map

**Purpose:** Determine where AI replaces, augments, or is inapplicable.

**For each derived asset type:**

1. **Traditional production method** — What's the legacy process?
2. **AI intervention decision** — Generate / Augment / Proceduralize / Replace process
3. **Primacy of AI application** — Primary / Secondary / Experimental / Not applicable

**Output:** `AIProductionStrategyMap`

**Structure:**
```
Asset: [type + description]
Traditional method: [how this is normally made]
AI strategy: [generate/augment/proceduralize/replace]
Primacy: [primary/secondary/experimental/N/A]
Rationale: [why this approach]
Risk: [what could go wrong]
Reversibility: [can we roll back if it fails]
```

---

#### Phase 10: Lock Decisions

**Purpose:** Surface decisions that cannot be probed, only made.

**Lock points:**
- Architecture boundaries
- Modality selections (audio vs visual vs haptic)
- Tone rules (diegetic only, no UI, etc.)
- System ownership (who/what controls this)

**Locks surface early, before cost explodes.**

**Output:** `LockDecisions`

**Structure:**
```
Lock: [what's being decided]
Options: [A, B, C]
Impact: [what this constrains downstream]
Reversibility cost: [cheap/moderate/expensive to undo]
Must lock by: [story ID or epic milestone]
```

---

#### Phase 11: CPT (Central Product Theme) Synthesis

**Purpose:** Collapse all causal knowledge into single grounding statement.

**CPT Evolution:**

1. **CPT-Draft** → Created after Known/Unknown/Constraints (before causality loops)
2. **CPT-Operating** → Created after first full causality loop (Gate 1 close)
   - Continues to evolve through Gates 2-3
3. **CPT-Final** → Created at Gate 3 closure (all epics/stories/CSI complete)

**CPT must answer:**
1. What the system IS (ontology)
2. Why it EXISTS (causal necessity)
3. How it MANIFESTS (user experience)
4. What makes it INEVITABLE (design invariants)
5. How AI RE-INVENTS PRODUCTION (not just features)

**CPT Structure:** (See Section 10 for complete schema)

---

#### Phase 12: CSI (Cognitive State Integrity) Encoding

**Purpose:** Eliminate ambiguity by encoding states, transitions, invalid conditions, decay, decision moments, and corruption patterns.

**CSI prevents:**
- Coarse-grained stories that require developer interpretation
- Edge cases discovered during build (expensive)
- State corruption happening silently
- Recovery paths invented ad-hoc

**CSI encodes for each epic:**
- Valid states (what can exist)
- Invalid states (what must never exist) — with confidence scores
- Decay states (valid → invalid over time)
- State transitions (with validation, failure modes, recovery)
- Forbidden transitions (with prevention mechanisms)
- Decision moments (choice points with options/defaults)
- Corruption patterns (detection, recovery, prevention)

**Output:** `CognitiveStateIntegrityModel`

**CSI enriches IET epics and stories** — epics are incomplete without CSI sections.

(See Section 9 for complete CSI specification)

---

#### Phase 13: Semantic UI Architecture

**Purpose:** Express intelligence dimensions and causality structure through semantic UI.

**Phase 13 happens THREE TIMES:**

**Phase 13a (Gate 1):**
- Identify semantic dimensions
- Initial semantic map
- CPT-Draft includes preliminary UI manifestation

**Phase 13b (Gate 2):**
- EFC visualization design
- Confidence expression patterns
- CPT-Operating includes refined semantic architecture

**Phase 13c (Gate 3):**
- Complete semantic specification
- All regions, components, states, transitions defined
- CPT-Final includes complete Semantic UI Architecture section

**Output:** `SemanticUIArchitecture` (integrated into CPT)

(See Section 11 for complete Semantic UI specification)

---

## 6. CONFIDENCE SYSTEM

### 6.1 What Confidence Means in ISD

Confidence is not belief and not probability.

**Confidence is a measure of how stable a conclusion remains under causal pressure.**

A confidence score answers one question:  
**"If we stress this conclusion with time, constraints, and alternative conditions, does it still hold?"**

### 6.2 Confidence Scale (Universal)

All confidence in ISD uses a 0.00 – 1.00 scale.

| Range         | Meaning                          |
| ------------- | -------------------------------- |
| 0.90 – 1.00   | Structurally inevitable          |
| 0.80 – 0.89   | Strong but still pressure-sensitive |
| 0.65 – 0.79   | Plausible but unstable           |
| 0.40 – 0.64   | Speculative                      |
| < 0.40        | Non-viable / eliminable          |

**Rules:**
- < 0.80 → cannot pass a gate
- ≥ 0.80 → admissible
- ≥ 0.90 → preferred for irreversible decisions

### 6.3 Confidence Is Always Multi-Factor

Confidence is never assigned directly. It is computed from four components:

```
Confidence = (Causal Stability × Evidence Quality × Constraint Alignment × Volatility Penalty)
```

Each component is scored independently.

### 6.4 Component Rubric

#### 6.4.1 Causal Stability (CS)

**Question:** Does this conclusion survive forward + backward causality loops?

| Score | Criteria                                        |
| ----- | ----------------------------------------------- |
| 1.0   | Required in both forward and backward projections |
| 0.8   | Required in one, strongly implied in the other  |
| 0.6   | Appears necessary only under certain parameters |
| 0.4   | Breaks under reasonable alternate futures       |
| 0.2   | Disappears when time is manipulated             |

#### 6.4.2 Evidence Quality (EQ)

**Question:** What grounds this conclusion?

| Score | Evidence Type                              |
| ----- | ------------------------------------------ |
| 1.0   | Empirical data, proven precedent, hard constraint |
| 0.8   | Strong analogs, internal system logic      |
| 0.6   | Reasoned inference                         |
| 0.4   | Assumption-based                           |
| 0.2   | Hypothetical only                          |

#### 6.4.3 Constraint Alignment (CA)

**Question:** How well does this align with immovable constraints?

| Score | Alignment                                     |
| ----- | --------------------------------------------- |
| 1.0   | Directly satisfies or is required by constraints |
| 0.8   | Fully compatible                              |
| 0.6   | Requires trade-offs                           |
| 0.4   | Conflicts with at least one constraint        |
| 0.2   | Violates constraints                          |

#### 6.4.4 Volatility Penalty (VP)

**Question:** How much does confidence vary across lenses, parameters, or runs?

Volatility is a penalty multiplier, not a score.

| Volatility (Δ) | Penalty  |
| -------------- | -------- |
| < 0.05         | × 1.00   |
| 0.05 – 0.10    | × 0.95   |
| 0.10 – 0.20    | × 0.85   |
| > 0.20         | × 0.70   |

### 6.5 Confidence at Each ISD Stage

#### 6.5.1 Gate 1 — Initial Causality Confidence

**Used for:**
- Estimating number of compression loops
- Deciding if Gate 1 can close

**Computed on:**
- Causal chains only (not features yet)

**Minimum to close Gate 1:**
- Global confidence ≥ 0.70
- Individual chain confidence recorded

#### 6.5.2 Gate 2 — Parametric Confidence

**Used for:**
- Measuring learning
- Detecting volatility
- Triggering EFC

**Computed on:**
- Chains + provisional features
- Across multiple parametric runs

**Key signal:**
- Volatility, not absolute score

#### 6.5.3 EFC Confidence

**Two scores are mandatory:**
- Pre-EFC Confidence
- Post-EFC Confidence

**Interpretation rules:**
- Confidence drop after expansion = healthy
- Confidence rise after compression = validation
- No change = likely shallow analysis

**EFC Success Condition:**
- Δ confidence < 0.05 across final two compressions
- Final confidence ≥ threshold

#### 6.5.4 Pre-Gate 3 Global Confidence

**Computed on:**
- All inevitable features

**Rule:**
- Lowest confidence item bounds the system

**Gate 3 requires:**
- Global ≥ 0.80 (min)
- ≥ 0.90 for core architecture

#### 6.5.5 Epic Confidence (Inherited + Adjusted)

```
Epic Confidence = min(confidence of supporting causal chains)
                  × interface complexity factor
                  × EFC adjustment (if applied)
```

**Rule:**
No epic may exceed the confidence of its weakest causal support.

#### 6.5.6 Story Confidence

Story confidence is local, not global.

**Used to:**
- Order implementation
- Flag risk
- Identify test intensity

**Low-confidence stories are allowed only if:**
- They do not affect system invariants
- They are reversible

### 6.6 Confidence Decay & Recalculation

Confidence is not static.

**Recalculate confidence when:**
- New constraints are introduced
- New data is ingested
- Architecture changes
- CSI reveals new invalid states
- EFC expands scope

**Agent behavior:**
- Agent auto-recalculates when these events occur
- Agent notifies user: "Confidence recalculated - [feature X] dropped from 0.85 to 0.72 due to [new constraint Y]"
- User can manually trigger: "Recalculate confidence for [feature/epic]"

### 6.7 Confidence on Invalid States

Invalid states DO have confidence scores.

**Confidence on invalid state = likelihood that invalid state could occur**

- High confidence invalid state = high risk, needs prevention mechanism
- Low confidence invalid state = edge case, monitor but don't over-engineer

### 6.8 Teaching Rule (Human-Safe)

**"Confidence is not how sure you feel — it's how little changes when you stress the idea."**

That sentence is enough for onboarding.

### 6.9 Agent Enforcement Rules (Confidence)

**Agents must:**
- Show confidence components, not just totals
- Explain drops explicitly
- Block gate progression below thresholds
- Recommend EFC when volatility is high

**Agents may not:**
- Smooth confidence artificially
- Average away volatility
- Inflate scores to proceed

### 6.10 Canonical Confidence Statement

**In ISD, confidence measures survival under pressure, not optimism.**

---

## 7. ELASTIC FIELD COMPRESSION (EFC)

### 7.1 Definition

**Elastic Field Compression (EFC)** is a controlled ISD technique that temporarily expands and compresses a localized causality field around a feature to reveal layered bands of potential and then deterministically collapse them into inevitability.

EFC does not invent features.  
EFC reveals what survives compression.

### 7.2 When EFC Is Used

EFC exists **after Gate 2 qualification** and **before Gate 3 closure**.

EFC is triggered when **BOTH conditions are true:**

1. Feature is determined to be **necessity** (survives time collapse)
2. Feature has **too many potentials to isolate** (causal chains are ambiguous/conflicting)

**In other words:**  
EFC validates "necessary but unclear" features.

### 7.3 The Elastic Field

The elastic field is the bounded causal space surrounding a feature, including:

- Dependencies
- Assumptions
- Preconditions
- Adjacent systems
- Human interaction points
- AI autonomy boundaries
- Governance constraints

The field is elastic because:
- It can stretch to surface possibilities
- It can contract to eliminate non-necessities
- It preserves continuity throughout

### 7.4 EFC Phases

#### Phase A — Field Expansion (Outward)

**Purpose:** Reveal bands of potential

**What happens:**
- Causal space is deliberately widened
- Unknowns increase (expected)
- Conditional paths emerge
- Confidence may temporarily decrease

**Outputs:**
- Potential bands (layered possibilities)
- Newly surfaced unknowns
- Hidden dependencies
- Assumption exposure

**This phase is allowed to be messy.**

#### Phase B — Field Compression (Inward)

**Purpose:** Isolate inevitability

**What happens:**
- The field contracts under constraints
- Non-load-bearing potentials fall away
- Invariants harden
- Confidence converges

**Outputs:**
- Inevitable sub-structures
- Demoted or eliminated features
- Refined feature definition
- Updated confidence score

**This phase must be deterministic.**

### 7.5 EFC Invocation Triggers (Mandatory)

EFC must run when **ANY** of these are true:

**Trigger T1 — Confidence Volatility**
- Feature-level confidence is high (≥0.80)
- But confidence varies widely across lenses (Δ ≥ 0.20)

**Trigger T2 — Boundary Crossing**
- Feature crosses two or more of:
  - Identity/auth boundary
  - Data ownership boundary
  - Compliance/audit boundary
  - External integration boundary
  - Human verification boundary
  - Model autonomy boundary

**Trigger T3 — Irreversibility**
- Feature implies decisions that are expensive to undo:
  - Core data model
  - Permission model
  - Event architecture
  - Tenancy model
  - Long-lived knowledge base structure

**Trigger T4 — Unknown Necessity**
- A necessity remains unknown due to missing info
- Blocks Gate 3 progression

**Trigger T5 — High Leverage Node**
- Feature is referenced by ≥3 other causal chains (hub node)

### 7.6 EFC Stop Conditions

#### Expansion Stop Condition

Stop expanding when **either:**
- No new potential bands appear for two consecutive probes, OR
- New unknowns introduced are duplicates or low-impact, OR
- Expansion exceeds scope budget (see 7.7)

#### Compression Exit Condition

EFC is "done" only when:

1. **Feature state becomes one of:**
   - Confirmed Inevitable
   - Expanded into sub-features (each classified)
   - Demoted / Eliminated (with reason)

2. **AND confidence stabilizes:**
   - Δ confidence < 0.05 across two compressions

3. **AND remaining unknowns are either:**
   - Non-blocking
   - Explicitly queued as research tasks

### 7.7 EFC Scope Budget (Anti-Sprawl)

EFC must declare:

- **Max probes:** 7 (default)
- **Max new unknowns:** 12 (default)
- **Max adjacent systems:** 3 (default)

**Budget enforcement by velocity:**
- **Sprint:** Hard budgets (auto-stop at limits)
- **Balanced:** Soft budgets (agent warns, user can continue)
- **Discovery:** User controls budgets explicitly

### 7.8 EFC Outputs (Required, Repeatable)

Every EFC run must produce:

1. **Elastic Field Map** — Before/after view
2. **Potential Band Register** — What appeared during expansion
3. **Collapse Result** — Confirmed / Expanded / Demoted
4. **Confidence Delta** — Pre-EFC vs Post-EFC
5. **Reasoned Elimination** (if applicable)

If these do not exist, EFC did not occur.

### 7.9 EFC Relationship to Build Branches

**Build Branches (Phase 5)** = resolution options at gaps  
**EFC** = validation technique for necessary but unclear features

**They are different:**
- Build Branches present multiple paths forward
- EFC validates whether a feature survives causality pressure

**They can interact:**
- A Build Branch may contain a feature that triggers EFC
- EFC result may eliminate a Build Branch

### 7.10 Teaching EFC (Human-Safe)

**"Elastic Field Compression expands the space around a feature to reveal all possible bands of potential, then compresses that space until only what must exist remains."**

That sentence is enough for onboarding.

---

## 8. INEVITABILITY-TO-EPIC TRANSFORMER (IET)

### 8.1 Purpose

Convert validated inevitabilities (from causality loops + confidence thresholds) into epics and stories.

IET operates during **Phase 6** at the start of Gate 3.

### 8.2 Core Rule: "No Free Epics"

**An epic must be traceable to at least one inevitable causal chain.**

**Epic validity test:**
```
Epic → (Inevitable Chain) → (Gate Closure Condition)
```

If not traceable, epic is "Speculative" and blocked until reclassified.

### 8.3 IET Inputs (Required Artifacts)

IET requires these inputs (no exceptions):

1. Causality Map (system-level)
2. Causality Separation Table (inevitable / conditional / eliminated)
3. Known/Unknown/Potential matrix
4. Confidence Report (per chain and global)
5. EFC results for any high-risk feature
6. CPT-Operating (current system synthesis)

### 8.4 Epic Schema (Canonical Shape)

IET produces proto-epics with this structure:

```markdown
### Epic [ID]: [Name]

**Gate Target:** [Which gate(s) this helps close]
**Inevitability Statement:** [One sentence: must exist because...]
**Supporting Causal Chains:** [Links to chain IDs]

**Inputs/Outputs:** [Data contracts - conceptual OK]
**Invariants:** [Must-never-break rules]
**Failure Modes:** [Primary breaks and detection]
**Dependencies:** [Hard vs soft vs stub-able]

**Confidence:** [Score inherited from chains]
**EFC Required:** [Yes/No]
**EFC Status:** [Not run / In progress / Complete - if applicable]

**Branch Selected:** [A/B/C + rationale] (from Phase 5)

**Assets Required:**
- [Asset 1]: [Type] — [Brief description]
- [Asset 2]: [Type] — [Brief description]

**UI Manifestation:** [What user sees/interacts with]
- View: [Which screen/component]
- Interaction: [What user does]
- Feedback: [What system shows]

**Dependencies:**
- Blocks: [Which other epics depend on this completing]
- Blocked by: [Which epics must complete first]

**Success Criteria:** [Observable outcome]

---

**[CSI sections added in Phase 12 - see Section 9]**
```

**Epics are incomplete until CSI encoding (Phase 12).**

### 8.5 Story Generation Rule ("Epic → Stories")

Stories are produced by cutting along interfaces:

**Interface Cuts:**
- Human interface (UI/UX)
- Data interface (models, schemas)
- Auth interface (permissions, roles)
- Integration interface (external systems)
- AI interface (prompting, model IO, eval)

Each interface cut produces at least one story.

### 8.6 Story Schema (Canonical)

```markdown
### Story [ID]: [Title]

**Epic:** [EP-X]
**Priority:** [Critical/High/Medium/Low]
**Effort:** [Hours/Days]
**Confidence:** [0.XX] (inherited from epic, adjusted for story risk)

**User Story:**
As a [role], I want to [action] so that [outcome].

**Purpose:** [Which gap this collapses]
**Question:** [What we're learning through this story]

**System Behavior:** [Deterministic description]
**Data Required:** [Fields, source, ownership]
**AI Behavior:** [Bounded autonomy + verification] (if applicable)

**Acceptance Criteria:**
- [ ] [Criterion 1 - testable]
- [ ] [Criterion 2]
- [ ] **UI Elements Created/Modified:**
  - [ ] [Component]: [What it displays/enables]
  - [ ] [State changes]: [What data updates]

---

**Semantic Context:** [Added in Phase 13c]
- Region: [Inevitability Core / Conditional Band / etc.]
- Confidence: [Score with visual expression guidance]
- Causality: [How this fits in backward/forward flow]
- Visual Expression: [Styling guidance based on semantic meaning]

---

**[CSI sections added in Phase 12 - see Section 9]**

---

**AI Strategy:** [Primary/Secondary/Not Applicable]
- Model: [Which AI model/service]
- Rationale: [Why this AI approach]
- Cost estimate: [Per operation/per month]

**Technical Notes:** [Implementation details]

**Dependencies:**
- **Blocks:** [Story IDs]
- **Blocked by:** [Story IDs]

**Telemetry/Evidence:** [What proves this worked]
**Cheap/Reversible:** [Yes/No + rationale]
```

### 8.7 IET Output Format

IET produces: `isd_epics_and_stories.md`

**Sections:**
1. Epics list (proto-epics, pre-CSI)
2. For each epic: full schema + stories
3. Open unknowns blocking story completion
4. Deferred features (with elimination reasons)
5. Causal dependency graph

---

## 9. COGNITIVE STATE INTEGRITY (CSI)

### 9.1 Purpose

CSI eliminates ambiguity by explicitly encoding system states, transitions, invalid conditions, decay patterns, decision moments, and corruption patterns **before implementation**.

**CSI prevents:**
- Coarse-grained stories that require developer interpretation
- Edge cases discovered during build (expensive)
- State corruption happening silently
- Recovery paths invented ad-hoc

**CSI ensures:**
- Edge cases are designed away, not discovered
- State transitions are explicit
- Invalid states are impossible, not handled
- Recovery paths are designed, not invented

### 9.2 When CSI Happens

CSI encoding occurs in **Phase 12** during Gate 3.

**CSI enriches:**
- Epics (after IET produces proto-epics)
- Stories (after interface cuts)

**Epics and stories are incomplete without CSI sections.**

### 9.3 CSI Requirements (Per Epic)

For each epic, encode:

#### 9.3.1 State Space Definition

**Valid States:**
```
State: [Name]
  Meaning: [What this state represents]
  Observable indicators: [How we know system is in this state]
  Entry conditions: [What must be true to enter]
  Exit conditions: [What must be true to leave]
  Lifespan: [How long system typically stays here]
```

**Invalid States (Must Never Exist):**
```
Invalid State: [Name]
  Why invalid: [What breaks if this exists]
  Prevention mechanism: [How system enforces non-existence]
  Detection: [How we spot if it happens anyway]
  Severity: [Critical/High/Medium]
  Confidence: [Likelihood this could occur - 0.XX]
```

**Decay States (Valid → Invalid Over Time):**
```
Decay Pattern: [Name]
  Trigger: [What starts the decay]
  Timeline: [How long until invalid]
  Warning signs: [Observable degradation]
  Recovery window: [Point of no return]
  Auto-recovery: [System self-correction, if any]
```

#### 9.3.2 State Transition Graph

**For Each Valid Transition:**
```
[State A] → [State B]:
  Trigger: [What causes this transition]
  Authority: [User/System/External API/Time-based]
  Preconditions: [What must be true before transition]
  Validation: [Checks performed during transition]
  Failure mode: [What happens if validation fails]
  Rollback: [How to undo if needed]
  Side effects: [What else changes]
  Irreversibility: [Can this be undone? Cost?]
  Typical duration: [How long transition takes]
```

**For Automatic Transitions:**
```
[State A] → [State B] (automatic):
  Trigger: [System event, timer, external signal]
  Conditions: [When system auto-transitions]
  User notification: [How user is informed]
  Override: [Can user prevent/delay?]
```

#### 9.3.3 Forbidden Transitions

**For Each Forbidden Path:**
```
[State A] ↛ [State C]:
  Why forbidden: [System invariant that breaks]
  Common attempt scenario: [When users try this]
  Prevention mechanism: [UI disabled, API rejects, validation blocks]
  Detection: [How we catch if prevention fails]
  Recovery: [What to do if forbidden transition occurs]
  User messaging: [Error shown to user]
```

#### 9.3.4 Decision Moments

**For Each Critical Choice:**
```
Decision Point: [Name]
  Context: [User is in State X, sees Y, needs to choose]
  
  Options:
    Option A: [Description]
      → Leads to: [State transition]
      → Irreversibility: [Can undo? Cost?]
      → Side effects: [What else happens]
      → Risk: [What could go wrong]
    
    Option B: [Description]
      → [same structure]
  
  Default behavior: [What happens if user doesn't choose]
    → Timeout: [Duration before auto-select]
    → Auto-selection: [Which option, why]
  
  Undo cost: [Comparison of reversibility across options]
  Information shown: [What user sees to make informed choice]
  Guidance: [What system recommends, if any]
```

#### 9.3.5 State Corruption Patterns

**For Each Known Corruption Risk:**
```
Corruption Pattern: [Name]
  
  Symptom: [Observable indicator something is wrong]
    - User sees: [UI manifestation]
    - System sees: [Data/state manifestation]
  
  Root cause: [How corruption happens]
    - Trigger scenario: [Specific sequence of events]
    - Probability: [Common/Rare/Edge case]
    - Confidence: [Likelihood - 0.XX]
  
  Detection mechanism: [How system catches this]
    - Automated check: [Cron job, validation hook, etc.]
    - Frequency: [Real-time, hourly, daily]
    - Alert threshold: [When to flag as problem]
  
  Recovery strategy: [How to fix]
    - Automatic: [System self-heals, if possible]
    - Manual: [Steps to restore valid state]
    - Data loss: [What's lost in recovery]
  
  Prevention: [How to make impossible]
    - Code change: [Validation, transaction boundary, etc.]
    - Architecture: [Design pattern that eliminates risk]
    - Monitoring: [Early warning system]
  
  Severity: [Critical/High/Medium]
  Frequency: [How often we expect this]
```

### 9.4 CSI Output

**Output:** `CognitiveStateIntegrityModel` (integrated into epics/stories)

### 9.5 CSI Quality Gates

Epics/stories are CSI-complete only when:

- [ ] **State Completeness:** Every user-facing interaction has a named state
- [ ] **Transition Coverage:** Every valid state has defined entry/exit paths
- [ ] **Failure Explicitness:** Every transition has explicit failure handling
- [ ] **Recovery Paths:** Every invalid state has documented recovery
- [ ] **Prevention Design:** Every corruption pattern has prevention mechanism
- [ ] **Decision Clarity:** Every choice point has explicit options and defaults

### 9.6 How CSI Integrates with Stories

Each story's acceptance criteria now includes:

- **States involved:** Which states this story creates/modifies
- **Transitions implemented:** Which state changes this enables
- **Invalid states prevented:** What this story ensures can't happen
- **Decision moments designed:** Choice points made explicit
- **Corruption patterns addressed:** What failure modes this handles

### 9.7 CSI Teaching Statement

**"CSI is not additional work—it's explicit encoding of what skilled developers already think about implicitly."**

The difference: With CSI, nothing is left implicit. Edge cases are designed away, not discovered.

---

## 10. CENTRAL PRODUCT THEME (CPT)

### 10.1 Definition

The CPT is the final synthesis that collapses all causal knowledge into a single grounding truth of the system.

**CPT is not a pitch. It is the crystallized truth of what the system is, why it exists, and how it manifests.**

### 10.2 CPT Evolution

CPT has three states:

1. **CPT-Draft** → Created after Known/Unknown/Constraints documented (before causality loops)
   - Initial hypothesis of what system might be
   - Created before Gate 1 causality work

2. **CPT-Operating** → Created after first full causality loop (Gate 1 close)
   - Grounded in inevitability from backward/forward collapse
   - Continues to evolve through Gates 2-3 as features clarify

3. **CPT-Final** → Created at Gate 3 closure (all epics/stories/CSI complete)
   - Complete grounding statement
   - Includes all semantic UI architecture
   - Ready for prototyping/implementation

### 10.3 CPT Must Answer

1. What the system **IS** (ontology from backward collapse)
2. Why it **EXISTS** (problems solved, value delivered, gaps closed)
3. How it **MANIFESTS** (user experience, system behavior, UI)
4. What makes it **INEVITABLE** (design invariants, locked decisions)
5. How AI **RE-INVENTS PRODUCTION** (not just features added)

### 10.4 CPT Serves As

- The canonical reference for all development
- The grounding context for prototyping
- The invariant truth against which all decisions are validated
- The complete product specification in narrative form

### 10.5 CPT Structure (Canonical)

```markdown
# [Product Name]

## Central Product Theme

### What It Is (System Ontology)

[One paragraph that defines the system's essence]

- **Core noun:** What is this thing? (e.g., "A manuscript evaluation system")
- **Key differentiator:** What makes it fundamentally different?
- **Boundary:** What it is NOT (to prevent scope creep)

---

### Why It Exists (Causal Necessity)

[The gaps this system closes in the world]

- **Problem it solves:** (backward from user pain)
- **Value it delivers:** (forward to user outcome)
- **Why traditional approaches fail:** (constraint that forced new design)
- **Why NOW:** (what changed that makes this possible/necessary)

---

### How It Manifests (Future State as Reality)

[Describe the system as if a user is experiencing it right now]

#### User's Daily Experience
[Concrete scenario: morning/workflow/outcome]

#### System Behavior
[What the system does—not what it's "for" but what it DOES]

#### Core Loops
[The fundamental cycles that create value]

1. **[Loop 1]:** User does X → System does Y → User sees Z → Repeat
2. **[Loop 2]:** [another core loop]
3. **[Loop 3]:** [if applicable]

#### UI Manifestation
[What user actually sees/touches/interacts with]

- **Primary views:** (dashboard, editor, export, etc.)
- **Key interactions:** (upload, score, compare, resolve)
- **Information architecture:** (how data flows through UI)

---

### What Makes It Inevitable (Design Invariants)

[The locked decisions that cannot be changed without breaking the system]

#### Structural Invariants
- **[Lock 1]:** [e.g., "Markdown is canonical format"]
  - Rationale: Enables clean export, preserves formatting, portable

- **[Lock 2]:** [e.g., "Onboarding through uploaded drafts, not manual description"]
  - Rationale: Reduces cognitive load, demonstrates intelligence, imports existing work

#### Technical Invariants
- **[Lock 1]:** [e.g., "JSONB for eval model dimensions"]
  - Rationale: User-defined criteria require flexible schema

- **[Lock 2]:** [e.g., "Real-time confidence scoring"]
  - Rationale: Users need immediate feedback on system certainty

#### UX Invariants
- **[Lock 1]:** [e.g., "Always show confidence alongside assessments"]
  - Rationale: Transparency builds trust, prevents over-reliance

- **[Lock 2]:** [e.g., "No dismissible error states"]
  - Rationale: Critical failures must block progression

---

### How AI Re-Invents Production (Not Features)

[Where AI doesn't "add capabilities" but eliminates entire production methods]

#### Primary AI (No Alternative)
- **[Asset 1]:** [How AI replaces traditional method]
  - Traditional: [How humans did this]
  - AI replaces: [What AI does instead]
  - Rationale: [Why human method breaks down]
  - Cost: [Estimate per operation]

- **[Asset 2]:** [Another primary AI asset]

#### Secondary AI (Augments Human)
- **[Asset 3]:** [How AI assists]
  - Traditional: [Human-led process]
  - AI augments: [Where AI helps]
  - Rationale: [Why hybrid is optimal]

#### Not AI
- **[Asset 4]:** [Why human/algorithmic method is better]
  - Rationale: [Why AI would fail or be suboptimal]

#### Cost Summary
- Per user onboarding: $[X]
- Per [unit of work]: $[Y]
- Monthly operational: $[Z] (assumes [usage pattern])

#### Risk Mitigation
[Known AI risks and how they're addressed]

---

### Semantic UI Architecture

[Complete semantic specification - added in Phase 13]

#### Semantic Dimensions

**Confidence:**
- Visual expression: Gradient intensity (0% = faint, 100% = solid), border weight, saturation
- Thresholds: >0.90 = solid border, 0.80-0.89 = medium, 0.65-0.79 = dashed, <0.65 = faint
- Data source: `confidence_score` field (float 0-1)

**Causality State:**
- Visual expression: Vertical layers, flow direction indicators, timeline
- Regions: Past (backward collapse), Present (current), Future (forward projection)
- Data source: `causality_phase` enum (backward | forward | synthesis)

**Feature Necessity:**
- Visual expression: Core = anchored/solid, conditional = floating/dashed, eliminated = ghosted
- Movement: Conditional → Inevitable when confidence crosses 0.80
- Data source: `necessity_status` enum (inevitable | conditional | eliminated)

**Gate Progression:**
- Visual expression: Progress indicator, unlocked sections, breadcrumb
- States: Gate 1 (discovery), Gate 2 (refinement), Gate 3 (execution)
- Data source: `current_gate` enum (gate1 | gate2 | gate3)

**EFC State:** (when active)
- Visual expression: Expanding/contracting field animation, radial layout
- Regions: Exploration Field (expansion), Compression Zone (contraction)
- Data source: `efc_status` enum (not_started | expanding | compressing | complete)

**[Additional dimensions as needed for specific system]**

---

#### Semantic Map

```
┌─────────────────────────────────────────────┐
│         CAUSALITY HORIZON                   │
│  (Future state - inevitability)             │
│  Visual: Timeline extending forward         │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│       CONFIDENCE GRADIENT                    │
│  High ═══ Medium ─── Low ···                │
│  Visual: Border weight + saturation         │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│         FEATURE NECESSITY                    │
│  [Inevitable] [Conditional] [Eliminated]    │
│  Visual: Solid / Dashed / Ghosted           │
└─────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────┐
│      EXECUTION READINESS                     │
│  Gate 1 → Gate 2 → Gate 3                   │
│  Visual: Progress bar + unlocked sections   │
└─────────────────────────────────────────────┘
```

---

#### Semantic Regions

**Region: Inevitability Core**
- **Role:** Features that survived causality collapse
- **Visual:** Solid borders, high contrast, anchored position, no dismiss
- **Entry conditions:** Confidence ≥ 0.80 + causal stability 1.0
- **Exit conditions:** New constraints that drop confidence OR causal break
- **Components:**
  - Epic cards (solid styling, action buttons enabled)
  - Story tiles (high priority indicators)
  - Locked decisions (immutable display)
- **Data query:** `GET /features?necessity=inevitable&confidence_min=0.80`

**Region: Conditional Band**
- **Role:** Features under consideration, awaiting validation or EFC
- **Visual:** Dashed borders, medium opacity, movable/sortable
- **Entry conditions:** Confidence 0.65-0.79 OR high volatility (Δ > 0.20)
- **Exit conditions:** Confidence crosses 0.80 (→ Inevitable) OR drops below 0.40 (→ Eliminated)
- **Components:**
  - Feature candidate cards (editable)
  - Resolution branch options (expandable)
  - EFC trigger buttons (if criteria met)
- **Data query:** `GET /features?necessity=conditional&confidence_min=0.65&confidence_max=0.79`

**Region: Exploration Field** (active during EFC)
- **Role:** Potential features during EFC expansion phase
- **Visual:** Faint outlines, low opacity, radial layout from center feature
- **Entry conditions:** EFC triggered, expansion phase active
- **Exit conditions:** EFC compression begins
- **Components:**
  - Potential band cards (concentric rings)
  - Hypothesis nodes (pulse animation)
  - Unknown indicators (highlighted in sidebar)
- **Data query:** `GET /efc/{feature_id}/expansion/potentials`

**Region: Eliminated Archive**
- **Role:** Features that failed causality or confidence thresholds
- **Visual:** Ghosted, collapsed by default, accessible via toggle
- **Entry conditions:** Confidence < 0.40 OR causal break detected OR reasoned elimination
- **Exit conditions:** Manual restoration if constraints change
- **Components:**
  - Eliminated feature list (collapsed)
  - Elimination reason display (expand to view)
  - Rollback indicators (if possible)
- **Data query:** `GET /features?necessity=eliminated`

---

#### Movement Rules

**Exploration → Conditional:**
- Trigger: EFC compression completes, confidence rises above 0.65
- Visual transition: Fade from radial to linear layout, opacity increases
- Duration: 0.5s ease-out animation
- API event: `POST /features/{id}/move {from: "exploration", to: "conditional"}`

**Conditional → Inevitable:**
- Trigger: Confidence crosses 0.80, causal chains validated
- Visual transition: Border solidifies, anchors to core region, action buttons activate
- Duration: 0.8s with confirmation pulse
- API event: `POST /features/{id}/promote {to: "inevitable"}`

**Conditional → Eliminated:**
- Trigger: Confidence drops below 0.40 OR causal break detected
- Visual transition: Fade to ghost, collapse into archive
- Duration: 0.3s fade-out
- API event: `POST /features/{id}/eliminate {reason: "..."}`

**Inevitable → Conditional:** (rare but possible)
- Trigger: New constraints introduced, confidence recalculated, drops below 0.80
- Visual transition: Border changes solid → dashed, warning indicator appears
- Duration: Immediate (no animation - signals problem)
- API event: `POST /features/{id}/demote {reason: "constraint_change"}`

---

#### UI States & Transitions

**State: Gate 1 (Discovery)**
- **UI shows:** Causality timeline, known/unknown matrix, CPT-Draft panel
- **Dominant region:** Exploration Field (wide open, many possibilities)
- **User affordances:**
  - Time manipulation sliders (backward/forward)
  - Constraint addition form
  - Unknown classification toggles
- **Navigation:** Limited (focused on causality discovery)

**State: Gate 2 (Refinement)**
- **UI shows:** Feature confidence scores, EFC progress indicators, CPT-Operating panel
- **Dominant region:** Conditional Band (narrowing focus)
- **User affordances:**
  - Parametric run controls
  - Lens switching (if Adaptive Synthesis enabled)
  - EFC trigger buttons (for eligible features)
  - Confidence recalculation requests
- **Navigation:** Expanded (can move between causality views and feature details)

**State: Gate 3 (Execution)**
- **UI shows:** Epics/stories with CSI, dependency graph, CPT-Final panel
- **Dominant region:** Inevitability Core (locked and ready)
- **User affordances:**
  - Story ordering/prioritization
  - Confidence review dashboard
  - Rollback access (to previous gates if needed)
  - Export/handoff to delivery tools
- **Navigation:** Full (all views accessible, system locked for execution)

---

#### Interaction Flows

**Flow: EFC Visualization**

1. **User triggers EFC on feature**
   - Click "Run EFC" button on conditional feature card
   - System validates EFC triggers (T1-T5)

2. **UI transitions to EFC mode:**
   - Feature card moves to center of screen
   - Exploration Field expands radially around feature
   - UI dims non-EFC elements
   - EFC control panel appears (pause/resume/cancel)

3. **During expansion:**
   - New potential bands pulse into view (concentric rings)
   - Confidence indicator oscillates (showing volatility)
   - Unknowns populate in sidebar (with counts)
   - Expansion budget counter visible (7 probes max)

4. **During compression:**
   - Non-load-bearing potentials fade out (one by one)
   - Remaining bands contract inward toward center
   - Confidence stabilizes (indicator smooths)
   - Unknown count decreases

5. **On completion:**
   - Feature moves to appropriate region (Inevitable/Conditional/Eliminated)
   - EFC summary modal appears (collapse result, confidence delta, unknowns resolved)
   - UI returns to normal mode
   - Notification: "[Feature] EFC complete - now [Inevitable/Conditional/Eliminated]"

**Flow: Confidence Recalculation**

1. **Event triggers recalculation:**
   - New constraint added
   - CSI reveals invalid state
   - Architecture change
   - Manual user request

2. **Affected features highlight:**
   - Pulse animation on impacted cards
   - "Recalculating..." indicator appears

3. **Confidence indicators animate:**
   - Number ticks from old to new value
   - Color shifts if crossing threshold
   - Border style changes if necessity changes

4. **Features that cross thresholds move regions:**
   - Smooth animation to new region
   - Region counts update

5. **Notification appears:**
   - "[N] features recalculated"
   - "[X] moved to Conditional"
   - "[Y] moved to Inevitable"
   - "[Z] eliminated"
   - Expandable detail view

**Flow: Gate Progression**

1. **Gate closure checklist fills:**
   - Checklist panel shows progress
   - Incomplete items highlighted
   - Blocking items marked red

2. **When complete:**
   - "Close Gate X" button activates (changes from disabled to primary)
   - Confidence summary shown (global + per chain/feature)

3. **User confirms gate closure:**
   - Click "Close Gate X"
   - Confirmation modal: "This will lock [current work] and advance to [next phase]. Continue?"

4. **UI transitions:**
   - Gate indicator advances (1 → 2 or 2 → 3)
   - New regions unlock/appear
   - Available actions change (new controls appear)
   - Locked regions become read-only
   - Celebration micro-animation

5. **CPT updates:**
   - Draft → Operating (Gate 1 close)
   - Operating → Final (Gate 3 close)
   - Version indicator updates
   - Change log accessible

---

#### Data/API Alignment

**Dimension: Confidence**
- **Backend field:** `confidence_score` (float 0.00-1.00)
- **API endpoints:**
  - `GET /isd/confidence/{feature_id}` - get confidence for feature
  - `POST /isd/confidence/recalculate` - trigger recalculation
  - `GET /isd/confidence/global` - get system-wide confidence
- **Schema:**
  ```json
  {
    "feature_id": "string",
    "confidence_score": 0.85,
    "components": {
      "causal_stability": 1.0,
      "evidence_quality": 0.8,
      "constraint_alignment": 0.9,
      "volatility_penalty": 0.95
    },
    "timestamp": "ISO8601",
    "previous_score": 0.72
  }
  ```
- **Updates:** On causality recalculation, EFC completion, constraint change

**Dimension: Causality State**
- **Backend field:** `causality_phase` (enum: backward | forward | synthesis)
- **API endpoints:**
  - `GET /isd/causality/current` - get current phase
  - `POST /isd/causality/advance` - move to next phase
- **Schema:**
  ```json
  {
    "current_phase": "backward",
    "completed_phases": ["backward"],
    "next_phase": "forward",
    "can_advance": true
  }
  ```
- **Updates:** On phase transition

**Dimension: Feature Necessity**
- **Backend field:** `necessity_status` (enum: inevitable | conditional | eliminated)
- **API endpoints:**
  - `GET /isd/features/{id}/necessity` - get necessity status
  - `POST /isd/features/{id}/promote` - move to inevitable
  - `POST /isd/features/{id}/eliminate` - move to eliminated
- **Schema:**
  ```json
  {
    "feature_id": "string",
    "necessity_status": "conditional",
    "confidence_score": 0.75,
    "causal_chains": ["chain_001", "chain_002"],
    "last_updated": "ISO8601",
    "status_history": [...]
  }
  ```
- **Updates:** On confidence threshold cross, EFC result, reasoned elimination

**Dimension: Gate**
- **Backend field:** `current_gate` (enum: gate1 | gate2 | gate3)
- **API endpoints:**
  - `GET /isd/gate/status` - get current gate and checklist
  - `POST /isd/gate/close` - close current gate
- **Schema:**
  ```json
  {
    "current_gate": "gate1",
    "checklist": {
      "items": [
        {"id": "c1", "label": "Known/Unknown documented", "complete": true},
        {"id": "c2", "label": "CPT-Draft created", "complete": true},
        ...
      ],
      "completion_percentage": 85
    },
    "can_close": false,
    "blocking_items": ["c5"]
  }
  ```
- **Updates:** On gate closure

**Dimension: EFC State**
- **Backend field:** `efc_status` (enum: not_started | expanding | compressing | complete)
- **API endpoints:**
  - `GET /isd/efc/{feature_id}/status` - get EFC status
  - `POST /isd/efc/{feature_id}/start` - trigger EFC
  - `GET /isd/efc/{feature_id}/expansion/potentials` - get expansion results
- **Schema:**
  ```json
  {
    "feature_id": "string",
    "efc_status": "compressing",
    "phase": "compression",
    "probes_used": 5,
    "max_probes": 7,
    "unknowns_added": 8,
    "unknowns_resolved": 3,
    "pre_confidence": 0.72,
    "current_confidence": 0.81,
    "potential_bands": [...]
  }
  ```
- **Updates:** During EFC execution

---

#### Implementation Notes

**For Developers:**
- Every UI element must map to a semantic dimension
- Confidence must always be visible (no hiding uncertainty)
- State transitions must animate to show intelligence evolution
- Region boundaries are semantic, not arbitrary
- Low confidence = visual de-emphasis (never hidden)

**For Designers:**
- Semantic dimensions come first, visual style second
- Movement between regions must be clear and purposeful
- Confidence thresholds dictate visual weight
- Invalid states and corruption risks need clear visual language
- Gate progression should feel like unlocking, not just advancing

**Performance Considerations:**
- Confidence recalculations can be expensive - debounce user input
- EFC visualization may need virtualization for >20 potentials
- Region transitions should be CSS-based (GPU accelerated)
- Real-time updates via WebSocket for collaborative editing

**Accessibility:**
- Confidence scores need text equivalents (not just color)
- Region changes need ARIA announcements
- EFC animations must be reducible (prefers-reduced-motion)
- Keyboard navigation for all region interactions

---

### The Completed System (Grounding Statement)

[Final synthesis—one paragraph that could be dropped into a prototype brief and generate the entire system]

This is a **[what]** that **[core behavior]**. Users **[primary workflow]** which enables them to **[outcome]**. The system distinguishes itself by **[key differentiator]**, made possible by **[AI-first approach]** and **[structural invariant]**. Unlike traditional **[alternatives]**, this system **[why it's inevitable]**. The complete experience flows from **[entry point]** through **[core loops]** to **[delivery mechanism]**, with every element existing because **[causal necessity]**. Intelligence dimensions are expressed through semantic UI architecture where **[confidence/causality/necessity]** are always visible, guiding users through **[Gate 1 → Gate 2 → Gate 3]** progression until the system achieves execution readiness.

```

### 10.6 CPT Quality Gates

CPT is complete only when:

- [ ] **Completeness:** Can a developer build the system from CPT alone? (with epics/stories as implementation guide)
- [ ] **Invariance:** If you change any "invariant," does the system break or become something else?
- [ ] **Falsifiability:** Can you test each claim? (e.g., "User uploads drafts" → test by trying to onboard without uploads)
- [ ] **Causality:** Does every "why" trace back to a gap from backward/forward collapse?
- [ ] **AI Clarity:** Is it clear where AI is primary vs secondary vs not applicable?
- [ ] **Semantic Completeness:** Are all intelligence dimensions defined and visually expressed?

### 10.7 How CPT Enables Prototyping

- Designer reads CPT → knows exact UI to build (semantic architecture guides layout)
- Engineer reads CPT → knows exact data model (invariants define schema)
- AI agent reads CPT → can generate functional prototype (grounding statement is executable)
- Stakeholder reads CPT → understands product without jargon (narrative form)

---

## 11. SEMANTIC UI ARCHITECTURE

### 11.1 Purpose

Semantic UI Architecture expresses intelligence dimensions and causality structure through meaning-driven UI design.

**Core principle:** Meaning before visuals.

### 11.2 When Semantic UI Happens

Semantic UI Architecture is developed in **Phase 13**, which occurs THREE TIMES:

1. **Phase 13a (Gate 1):** Identify semantic dimensions, create initial semantic map
2. **Phase 13b (Gate 2):** Design EFC visualization, refine confidence expression
3. **Phase 13c (Gate 3):** Complete semantic specification with all regions/components/states

### 11.3 The Semantic UI Process

#### Step 1: Identify Semantic Dimensions

Before any UI work, identify the **dimensions of meaning** present in this intelligence system.

**Common semantic dimensions:**
- Confidence (0-1.0 scale)
- Certainty vs Ambiguity
- Causality state (backward/forward/synthesis)
- Feature necessity (inevitable/conditional/eliminated)
- Gate progression (1/2/3)
- EFC state (not started/expanding/compressing/complete)
- Reasoning depth (surface → deep → strategic)
- Time/temporality
- Context depth
- Priority/severity
- Signal vs insight (raw → processed)

**Output format:**
```
SEMANTIC DIMENSIONS:
• Confidence: [description + visual expression guidance]
• Causality State: [description + visual expression guidance]
• [Other dimensions...]
```

#### Step 2: Build the Semantic Map

Create a **spatial representation of meaning** using:

**Semantic Regions:**
Define zones where different types of intelligence live.

**Examples from ISD:**
- Inevitability Core (high-confidence, causal-validated features)
- Conditional Band (features awaiting validation)
- Exploration Field (potentials during EFC)
- Eliminated Archive (features that failed causality)
- Causality Horizon (future state visualization)

**For each region, define:**
- Role (what belongs here)
- Visual expression (how it looks)
- Entry conditions (how items enter)
- Exit conditions (how items leave)
- Components (UI elements that live here)
- Data query (API call to populate)

**Movement Rules:**
How do items transition between regions as intelligence evolves?

**Examples:**
- Conditional → Inevitable: When confidence crosses 0.80
- Exploration → Conditional: When EFC compression completes
- Inevitable → Conditional: When new constraints drop confidence

#### Step 3: Express Semantic UI Components

Translate semantic structure into UI expression.

**For each semantic dimension, define:**
- Visual expression method
- Threshold-based styling
- State changes and animations
- Data source and mapping

**For each semantic region, define:**
- Component types (cards, lists, graphs, etc.)
- Styling based on semantic meaning
- Interaction affordances
- Data requirements

#### Step 4: Map Data & API to Semantic Structure

For every semantic region and dimension, define:
- Backend fields
- API endpoints
- Schema
- Update triggers

#### Step 5: Define Interaction Flows

Document how users interact with semantic structures:
- EFC visualization flow
- Confidence recalculation flow
- Gate progression flow
- Feature movement between regions
- [System-specific flows]

### 11.4 Semantic UI Rules

1. **Always start with semantic dimensions** — Never skip to UI
2. **Semantic map comes before components** — Structure precedes expression
3. **Every visual element must map to meaning** — No decorative-only UI
4. **Express uncertainty visibly** — Don't hide low confidence
5. **Design for movement** — Intelligence changes; UI must show transitions
6. **Map all backend data** — Every semantic element needs data source
7. **Confidence always visible** — Never hide system certainty levels

### 11.5 Semantic UI Anti-Patterns

❌ Starting with "Here's a dashboard with these widgets..."  
✅ Starting with "The semantic dimensions are..."

❌ "This card shows the data"  
✅ "This card expresses high-confidence structural insights from backward collapse"

❌ Generic UI without semantic meaning  
✅ Every UI element tied to intelligence dimension

❌ Static screens  
✅ Living semantic structures that show intelligence evolution

### 11.6 Semantic UI Output

Semantic UI Architecture is integrated into **CPT-Final** (see Section 10.5).

It includes:
- Semantic Dimensions (complete list with visual expressions)
- Semantic Map (regions, movement rules)
- UI States & Transitions (by gate)
- Interaction Flows (key user journeys)
- Data/API Alignment (complete mapping)
- Implementation Notes (guidance for developers/designers)

### 11.7 Semantic UI Teaching Statement

**"Semantic UI expresses the meaning structure of intelligence before defining visual style."**

Users must understand **what the system knows** before they interact with **how it looks**.

---

## 12. VELOCITY MODES

### 12.1 Purpose

Velocity modes allow ISD to adapt execution style to user needs without sacrificing rigor.

### 12.2 Three Velocity Modes

**Sprint Mode:**
- Auto-resolve gaps based on anchors + cheapest path
- No explanations unless ambiguous
- Agent completes gate checklists automatically
- Deliver complete output quickly
- If gate cannot close (confidence too low), agent PAUSES and switches to Balanced

**Balanced Mode:**
- Present major gaps with top 2 resolution options
- User selects branches
- Agent recommends but user decides on gate closure
- Provide brief context on non-obvious choices

**Discovery Mode:**
- Present each major gap with 3 resolution branches
- Explain tradeoffs (cheap/expensive, reversible/binding, etc.)
- User controls EFC budgets explicitly
- User selects branches OR asks to explore further
- Offer to compare alternative branch combinations

### 12.3 Velocity Detection

ISD detects velocity from user behavior patterns:

**Sprint signals:**
- Direct task statements
- "Just give me..."
- "No explanation needed"
- Known user preference (e.g., Preston defaults to Sprint)

**Balanced signals:**
- "Help me understand..."
- "What are the options..."
- Comparative questions
- New complex domain

**Discovery signals:**
- "I'm not sure..."
- "What should I consider..."
- Explicit exploration requests
- Early ideation phase

### 12.4 Velocity Defaults

**System-wide default:** Balanced (safe for all users)

**User-specific defaults:** Stored in user profile
- Preston: Sprint
- [Other users]: Balanced unless specified

**Context override:**
- If user's first message contains velocity signals, use that
- Agent can ask: "Which velocity mode?" if ambiguous

### 12.5 Velocity Override Mid-Execution

User can switch velocity modes mid-run:

**Sprint → Balanced:**
- Pause at next gap
- Present options instead of auto-resolving

**Sprint → Discovery:**
- Pause at next gap
- Present 3 options instead of auto-resolving

**Balanced → Sprint:**
- Continue with auto-resolve from here
- No more option presentations

**Discovery → Balanced:**
- Collapse to top 2 options
- Continue with streamlined presentations

**Discovery → Sprint:**
- Auto-resolve remaining gaps
- No more option presentations

### 12.6 Velocity and Gate Authority

Gate closure behavior varies by velocity (see Section 4.2):

- **Sprint:** Auto-complete checklists, pause only if blocked
- **Balanced:** Present status, recommend, user decides
- **Discovery:** Full transparency, user controls

### 12.7 Velocity and EFC

EFC behavior varies by velocity:

**Sprint:**
- Auto-trigger EFC when criteria met
- Auto-run expansion/compression
- No pause for user input
- Present result only

**Balanced:**
- Auto-trigger EFC when criteria met
- Pause after expansion to confirm direction
- Present compression result for approval

**Discovery:**
- Present EFC trigger recommendation
- User confirms start
- Pause after expansion with options
- User controls compression parameters
- Present detailed result analysis

### 12.8 Velocity Teaching Statement

**"Velocity determines execution style, not output quality. All modes produce complete, rigorous ISD artifacts."**

---

## 13. AGENT ENFORCEMENT RULES

### 13.1 Purpose

Agents executing ISD must follow strict enforcement rules to maintain methodology integrity.

### 13.2 Gates (Agent Must Enforce)

**Agents must:**
- Enforce gate sequence (no skipping)
- Block progression when confidence < threshold
- Complete gate checklists before closure
- Track gate status explicitly

**Agents may not:**
- Skip gates
- Close gates without checklist completion
- Proceed with confidence < 0.40 (non-viable)

### 13.3 Causality (Agent Must Enforce)

**Agents must:**
- Run backward collapse before forward simulation
- Detect gaps automatically
- Surface contradictions immediately
- Track causal chains with IDs

**Agents may not:**
- Invent inevitability
- Skip causality loops
- Proceed with circular dependencies

### 13.4 Confidence (Agent Must Enforce)

**Agents must:**
- Calculate confidence using 4-component formula
- Show confidence components, not just totals
- Explain confidence drops explicitly
- Block gate progression below thresholds
- Recommend EFC when volatility > 0.20
- Recalculate confidence when events trigger it
- Notify user of confidence changes

**Agents may not:**
- Smooth confidence artificially
- Average away volatility
- Inflate scores to proceed
- Hide low confidence

### 13.5 EFC (Agent Must Enforce)

**Agents must:**
- Trigger EFC automatically when T1-T5 conditions met (velocity-dependent)
- Enforce scope budgets (Sprint = hard, Balanced = soft, Discovery = user-controlled)
- Track expansion/compression phases
- Record pre/post confidence
- Produce all required EFC outputs

**Agents may not:**
- Skip EFC when triggered
- Exceed scope budgets without user override
- Complete EFC without stabilized confidence

### 13.6 IET (Agent Must Enforce)

**Agents must:**
- Refuse speculative epics (no causal chain = blocked)
- Validate causal support before epic creation
- Generate epics with complete schema
- Flag epics as incomplete until CSI encoded

**Agents may not:**
- Create epics without causal justification
- Proceed to stories before epics validated
- Skip CSI encoding

### 13.7 CSI (Agent Must Enforce)

**Agents must:**
- Encode CSI for every epic
- Flag stories as incomplete without CSI sections
- Identify invalid states with confidence scores
- Define prevention mechanisms for corruption patterns
- Document recovery paths

**Agents may not:**
- Skip CSI encoding
- Mark epics/stories complete without CSI
- Leave edge cases implicit

### 13.8 Semantic UI (Agent Must Enforce)

**Agents must:**
- Identify semantic dimensions before UI design
- Map every UI element to semantic dimension
- Express confidence visibly
- Show intelligence evolution through UI
- Define all data/API mappings

**Agents may not:**
- Create decorative-only UI
- Hide confidence from users
- Design static UIs for dynamic intelligence

### 13.9 Velocity (Agent Must Adapt)

**Agents must:**
- Detect velocity from user behavior
- Adapt execution style to velocity
- Switch velocity when appropriate (e.g., Sprint → Balanced if blocked)
- Respect user velocity overrides

**Agents may not:**
- Force velocity on user
- Ignore velocity signals
- Sacrifice rigor for speed (even in Sprint)

### 13.10 Rollback (Agent Must Support)

**Agents must:**
- Store causality state history
- Enable rollback to prior states
- Preserve Build Branches until IET locks
- Track rollback points explicitly

**Agents may not:**
- Discard prior states
- Make rollback impossible
- Lock before user confirms

### 13.11 Teaching (Agent Must Adapt)

**Agents must:**
- Use teaching statements for onboarding
- Explain ISD concepts when asked
- Surface learning opportunities
- Adapt explanations to user expertise

**Agents may not:**
- Assume user knows ISD
- Skip teaching when velocity = Discovery
- Use jargon without explanation

---

## 14. GATE CLOSURE CHECKLISTS

### 14.1 Purpose

Gates close only when objective criteria are met. Checklists make closure deterministic.

### 14.2 Gate 1 Closure Checklist

Gate 1 is closed when all are true:

- [ ] Known / Unknown / Immovable documented
- [ ] CPT-Draft created (initial synthesis)
- [ ] Forward Time Projection completed (mature state)
- [ ] Backward Time Rollback completed (zero state)
- [ ] First Causality Delta produced (what must exist)
- [ ] Initial Causality Separation Table created (inevitable/conditional/eliminated)
- [ ] Initial Confidence Report produced (global + per chain)
- [ ] Blocking Unknowns labeled as:
  - [ ] Necessary unknown
  - [ ] Optional unknown
  - [ ] Eliminated unknown
- [ ] CPT-Operating created (first full synthesis)
- [ ] Phase 13a complete (semantic dimensions identified)
- [ ] Global confidence ≥ 0.70

**Output required:** `gate1_closure.md`

### 14.3 Gate 2 Closure Checklist

Gate 2 is closed when:

- [ ] User can run parametric time manipulation with guidance
- [ ] At least 2 parametric runs executed (different parameters)
- [ ] Adaptive Synthesis lenses invoked (≥3 lenses) — if available
- [ ] Confidence scoring used and interpreted by user
- [ ] One "demotion" or "expansion" example captured (shows learning)
- [ ] User can state:
  - [ ] How to surface unknowns
  - [ ] How to convert unknowns into research tasks
- [ ] All features that meet EFC triggers have EFC results
- [ ] EFC outputs produced for each run:
  - [ ] Elastic Field Map
  - [ ] Potential Band Register
  - [ ] Collapse Result
  - [ ] Confidence Delta
  - [ ] Reasoned Elimination (if applicable)
- [ ] CPT-Operating evolved with feature clarity
- [ ] Phase 13b complete (EFC visualization designed)

**Output required:** `gate2_closure.md`

### 14.4 Pre-Gate 3 Readiness Checklist

Before Gate 3 begins:

- [ ] All features that meet EFC triggers (T1-T5) have EFC results
- [ ] "Necessary Unknowns" are either:
  - [ ] Resolved
  - [ ] Research-tasked with plan
  - [ ] Bounded with assumptions + risk
- [ ] Global confidence ≥ 0.80 (minimum)
- [ ] Core architecture features ≥ 0.90 confidence
- [ ] No unresolved boundary-crossing ambiguity remains
- [ ] Causality Separation Table finalized
- [ ] Build Branches resolved (selections made)

**Output required:** `pre_gate3_readiness.md`

### 14.5 Gate 3 Closure Checklist

Gate 3 is closed when:

- [ ] All gaps transformed into epics via IET
- [ ] All epics have CSI encoding complete:
  - [ ] Valid states defined
  - [ ] Invalid states identified with prevention
  - [ ] Decay states documented
  - [ ] State transitions explicit
  - [ ] Forbidden transitions prevented
  - [ ] Decision moments designed
  - [ ] Corruption patterns addressed
- [ ] All epics cut into stories along interfaces
- [ ] All stories have complete schema including:
  - [ ] User story
  - [ ] Purpose & question
  - [ ] Acceptance criteria
  - [ ] CSI sections
  - [ ] Semantic context
  - [ ] AI strategy
  - [ ] Dependencies
  - [ ] Telemetry/evidence
- [ ] Causal Dependency Graph produced
- [ ] AI Production Strategy Map complete
- [ ] Lock Decisions documented
- [ ] CPT-Final synthesized with:
  - [ ] Complete Semantic UI Architecture
  - [ ] All design invariants
  - [ ] Complete grounding statement
- [ ] Phase 13c complete (full semantic specification)
- [ ] Global confidence ≥ 0.80
- [ ] No blocking unknowns remain

**Output required:** `gate3_closure.md` + complete ISD artifact bundle

---

## 15. REQUIRED ARTIFACTS

### 15.1 Purpose

ISD produces structured artifacts that serve as execution handoff to development teams.

### 15.2 Artifact Structure

**Single unified output document:**

```
ISD_OUTPUT.md

Sections:
1. Executive Summary
2. Central Product Theme (CPT-Final)
3. Gate Closure Reports
   - Gate 1 Closure
   - Gate 2 Closure
   - Pre-Gate 3 Readiness
   - Gate 3 Closure
4. Causality Artifacts
   - Forward Projection
   - Backward Collapse
   - Causality Map
   - Causality Separation Table
5. Confidence Reports
   - Global Confidence
   - Per-Chain Confidence
   - Per-Feature Confidence
   - Confidence History
6. EFC Results (for each feature)
   - Elastic Field Map
   - Potential Band Register
   - Collapse Result
   - Confidence Delta
7. Epics & Stories
   - Epic schemas (with CSI)
   - Story schemas (with CSI + Semantic Context)
   - Causal Dependency Graph
8. AI Production Strategy
   - Primary AI assets
   - Secondary AI assets
   - Not AI assets
   - Cost summary
   - Risk mitigation
9. Lock Decisions
10. Semantic UI Architecture (complete)
11. Implementation Guidance
12. Validation Report
```

### 15.3 Artifact Quality Gates

Output is complete only when:

- [ ] CPT-Final passes all quality gates (Section 10.6)
- [ ] All epics have CSI encoding
- [ ] All stories have complete schemas
- [ ] Semantic UI Architecture defines all dimensions/regions/flows
- [ ] Confidence scores present throughout
- [ ] Dependencies are explicit and non-circular
- [ ] AI strategy has cost estimates and rationale
- [ ] Lock decisions documented with impact analysis

---

## 16. TEACHING & ONBOARDING

### 16.1 Purpose

ISD teaching aclimates users to the methodology through agentic expression.

### 16.2 Teaching Principles

1. **Metaphors before mechanics** — Use puzzle analogy, elastic field language
2. **Experience before explanation** — Run causality loops before explaining theory
3. **Confidence as survival** — Teach "how little changes when you stress the idea"
4. **Gates as unlocking** — Progression feels like earning access, not advancing arbitrarily
5. **EFC as validation** — Not a failure, but a refinement technique

### 16.3 Onboarding Flow

**Stage 1: First Contact**
- User declares future state
- ISD asks: "What's the problem to shape?"
- No system announcements

**Stage 2: Gate 1 Introduction**
- Explain Known/Unknown/Immovable
- Demonstrate backward collapse (simple example)
- Show forward simulation (simple example)
- Surface first gap
- Explain confidence basics

**Stage 3: Gate 2 Mastery**
- Teach parametric manipulation
- Run first EFC (guided)
- Show confidence volatility
- Introduce Adaptive Synthesis (if available)
- User demonstrates learning

**Stage 4: Gate 3 Execution**
- Explain IET (inevitability → epics)
- Introduce CSI (states, transitions, corruption)
- Show Semantic UI mapping
- Complete first end-to-end ISD run

### 16.4 Teaching Statements (Human-Safe)

**On ISD:**
"ISD discovers what must exist by collapsing causality backward from the future, simulating forward from today, and using the collision to reveal inevitable structure."

**On Confidence:**
"Confidence is not how sure you feel—it's how little changes when you stress the idea."

**On EFC:**
"Elastic Field Compression expands the space around a feature to reveal all possible bands of potential, then compresses that space until only what must exist remains."

**On CSI:**
"CSI is not additional work—it's explicit encoding of what skilled developers already think about implicitly."

**On Semantic UI:**
"Semantic UI expresses the meaning structure of intelligence before defining visual style."

**On Gates:**
"Gates aren't arbitrary checkpoints—they're earned closure of causal completeness."

### 16.5 Adaptive Synthesis (Reference)

**Note:** Adaptive Synthesis is part of Preston's separate methodology and will be fully integrated when implemented.

**Current understanding:**
- Adaptive Synthesis enables multi-perspective causality analysis through synthetic roles/lenses
- Used in Gate 2 for parametric causality manipulation
- Lenses stress-test features across domains (Security, UX, Cost, Performance, Compliance, etc.)
- Increases confidence through multi-angle validation
- Surfaces cross-domain conflicts early

**Integration point:** Gate 2, after user demonstrates causality mastery

---

## 17. CANONICAL STATEMENTS

### 17.1 ISD Identity Statement

**"Inevitable Systems Design identifies necessity before effort, causality before construction, and confidence before commitment."**

### 17.2 Core Mechanism Statement

**"ISD collapses causality backward from assumed futures and simulates forward from constrained reality. The collision reveals what must exist."**

### 17.3 Confidence Statement

**"In ISD, confidence measures survival under pressure, not optimism."**

### 17.4 EFC Statement

**"Elastic Field Compression is how ISD explores depth without losing inevitability."**

### 17.5 CSI Statement

**"Cognitive State Integrity eliminates coarse-grained stories by encoding states, transitions, invalid conditions, decay patterns, decision moments, and corruption detection—making edge cases explicit during design, not discovered during build."**

### 17.6 CPT Statement

**"The Central Product Theme is the crystallized truth of what the system is, why it exists, how it manifests, what makes it inevitable, and how AI re-invents production."**

### 17.7 Semantic UI Statement

**"Semantic UI Architecture expresses intelligence dimensions and causality structure through meaning-driven design where confidence, necessity, and progression are always visible."**

### 17.8 Velocity Statement

**"Velocity determines execution style, not output quality. All modes produce complete, rigorous ISD artifacts."**

### 17.9 Gates Statement

**"Gates are irreversible. Skipping a gate invalidates downstream output."**

### 17.10 Final Canonical Statement

**"Inevitable Systems Design discovers what must exist by collapsing causality backward from assumed future states, simulating forward under constraints, validating through Elastic Field Compression, encoding precision via Cognitive State Integrity, synthesizing into a Central Product Theme, and expressing through Semantic UI Architecture—producing confidence-weighted, agent-executable artifacts ready for implementation."**

---

## END OF SPECIFICATION

**ISD v1.3 — Unified Canonical Specification**  
**Complete and Ready for Agentic Integration**

**Version History:**
- v1.0 — Initial specification with 12 phases, CPT, CSI
- v1.1 — Added Elastic Field Compression (EFC)
- v1.2 — Added Gate Model, IET, Confidence System
- v1.3 — Unified specification with Semantic UI Architecture, complete integration

**This document is now the single source of truth for Inevitable Systems Design.**

---

**Agent Implementation Note:**

This specification is designed to be directly executable by AI agents. Every section includes:
- Deterministic rules
- Explicit enforcement requirements
- Quality gates
- Output schemas
- Teaching guidance

Agents should:
1. Load this specification as context
2. Follow phase sequence exactly
3. Enforce gates without exception
4. Calculate confidence using formula
5. Trigger EFC automatically when conditions met
6. Produce artifacts in specified format
7. Express semantic UI architecture
8. Adapt to velocity while maintaining rigor

**The specification is complete. ISD v1.3 is ready for production use.**
